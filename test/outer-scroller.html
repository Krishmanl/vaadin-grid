<!doctype html>

<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="../../iron-test-helpers/mock-interactions.js"></script>

  <link rel="import" href="helpers.html">
  <link rel="import" href="../vaadin-grid.html">
</head>

<body>

  <test-fixture id="default">
    <template>
      <vaadin-grid style="width: 50px; height: 400px;" size="10">
        <vaadin-grid-column width="200px" frozen>
          <template class="header">header</template>
          <template>[[index]]</template>
          <template class="footer">footer</template>
        </vaadin-grid-column>
      </vaadin-grid>
    </template>
  </test-fixture>

  <test-fixture id="content-only">
    <template>
      <vaadin-grid style="width: 50px; height: 400px;" size="1">
        <vaadin-grid-column width="200px" frozen>
          <template>
            <div style="height: 1000px"></div>
          </template>
        </vaadin-grid-column>
      </vaadin-grid>
    </template>
  </test-fixture>

  <script>
    describe('outer scroller', function() {
      var grid;
      var scroller;
      var outerScroller;
      var target;
      var tableRect;

      beforeEach(function(done) {
        grid = fixture('default');
        grid.dataSource = infiniteDataSource;
        scroller = grid.$.scroller;
        outerScroller = scroller.$.outerscroller;
        outerScroller.hidden = false;
        target = outerScroller.scrollTarget;
        tableRect = scroller.$.table.getBoundingClientRect();
        Polymer.Base.async(done, 1);
      });

      it('should invoke onScroll synchronously', function() {
        var spy = sinon.spy(scroller, '_translateStationaryElements');
        outerScroller._syncScrollTarget();
        expect(spy.called).to.be.true;
      });

      it('should invoke frozen element translate handler', function(done) {
        var spy = sinon.spy(scroller, '_translateStationaryElements');
        outerScroller.scrollLeft = 1;
        setTimeout(function() {
          expect(spy.called).to.be.true;
          done();
        }, 200);
      });

      it('should have the same size as the scroller', function() {
        var outerRect = outerScroller.getBoundingClientRect();
        expect(outerRect.left).to.eql(tableRect.left);
        expect(outerRect.right).to.eql(tableRect.right);
        expect(outerRect.top).to.eql(tableRect.top);
        expect(outerRect.bottom).to.eql(tableRect.bottom);
      });

      it('should have the same scrollHeight/scrollWidth as the target', function() {
        expect(outerScroller.scrollHeight).to.eql(target.scrollHeight);
        expect(outerScroller.scrollWidth).to.eql(target.scrollWidth);
      });

      describe('syncing with scroll target', function() {

        it('should scroll the target', function(done) {
          outerScroller.addEventListener('scroll', function() {
            expect(target.scrollLeft).to.equal(1);
            done();
          });
          outerScroller.scrollLeft = 1;
        });

        it('should scroll the outer scroller', function(done) {
          target.addEventListener('scroll', function() {
            expect(outerScroller.scrollLeft).to.equal(1);
            done();
          });
          target.scrollLeft = 1;
        });

      });

      describe('passtrough pointer events', function() {

        function outerScrollerInUse() {
          return window.getComputedStyle(outerScroller).pointerEvents !== 'none';
        }

        it('should passtrough pointer events', function(done) {
          scroller.addEventListener('mousemove', function() {
            expect(outerScrollerInUse()).to.be.false;
            done();
          });

          MockInteractions.makeMouseEvent('mousemove', {x: 1, y: 1}, scroller);
        });

        it('should not passtrough if and only if scrollbars exist (vertical scrollbar hover)', function(done) {
          scroller.addEventListener('mousemove', function() {
            expect(outerScrollerInUse()).to.be[getScrollbarWidth() > 0 ? 'true' : 'false'];
            done();
          });
          MockInteractions.makeMouseEvent('mousemove', {x: tableRect.width, y: 1}, scroller);
        });

        it('should not passtrough if and only if scrollbars exist (horizontal scrollbar hover)', function(done) {
          scroller.addEventListener('mousemove', function() {
            // TODO: @limonte revisit in future
            if (!firefox) { // firefox has the blinking issue here (current version is 50)
              expect(outerScrollerInUse()).to.be[getScrollbarWidth() > 0 ? 'true' : 'false'];
            }
            done();
          });
          MockInteractions.makeMouseEvent('mousemove', {x: 1, y: tableRect.height}, scroller);
        });

      });

    });

    describe('content-only', function() {
      var grid;
      var scroller;
      var outerScroller;

      beforeEach(function(done) {
        grid = fixture('content-only');
        grid.dataSource = infiniteDataSource;
        scroller = grid.$.scroller;
        outerScroller = scroller.$.outerscroller;
        outerScroller.hidden = false;
        Polymer.Base.async(done, 1);
      });

      it('should have the correct scrollHeight', function() {
        var rows = getRows(scroller.$.items);
        var cells = getRowCells(rows[0]);
        var expectedScrollHeight = cells[0].offsetHeight;
        expect(outerScroller.scrollHeight).to.eql(expectedScrollHeight);
      });
    });
  </script>

</body>

</html>
